%%%
title = "Lachesis Consensus Protocol"
abbrev = "Lachesis Consensus Protocol"
area = "Internet"
workgroup = "Fantom"
keyword = ["consensus"]
#date = 2019-12-07T00:00:00Z

[seriesInfo]
name = "RFC"
value = "1912839"
status = "informational"

[[author]]
surname="Sharma"
fullname="Rishab Sharma"
organization = "Fantom Foundation"
  [author.address]
  email = "rishab.sharma@fantom.foundation"
%%%

{mainmatter}

# Introduction

The lachesis protocol allows a group of participants to agree upon the occurence and ordering of 
events over a network. The lachesis consensus protocol can be used to implement the common 
knowledge abstraction layer in the Fantom framework. The particpants must know each other and agree upon the total number of participants in the network. Participants submit events to the network and the network comes 
to consensus on the ordering and validity of these events using the lachesis protocol. The lachesis
consensus protocol can be used to implement the replicated datastore interface.

This document specifies how a lachesis network participant should behave.
    
## Participants

The participants in the network are mutually agreed upon. Participants are identified by a unique public key. Each particpant must store the public key, the IP address and the Creator's Id of every other participant in the network to disk. 

A participant may request another participant for a list of participants. The receving participant must respond with a list of participants it knows.
The response message must include the IP address, public key and ID of the participants signed by the responding participant.

### Adding Participants
Todo

### Removing Participants
Todo

## Clients (Will probably change with proof of stake implementation)

Clients are programs that interact with participants. Clients can request a participant to create event blocks on the lachesis network.

A client sends a payload and a unique payload identifier to the Participant. The participant can create an event block using the payload. If the particpant has accepted the payload, the particpant will respond with message indicating the payload is pending. If the participant decides to reject the payload, the particpant must respond with a rejected message indicating that the payload is 

### Client Authentication Process

Undefined in golang implementation

A client can updats on the status of their submitted payload by subscribing to messages from a participant. 
The participant will send messages including the unique payload identifier and the status of the message (pending, final, rejected).

## Events

A network event consists of an event header and the payload.

### Event Format

1. Header
2. Payload

#### Header

1. Event Hash: the SHA3-256 hash generated by signing 1, 2, 3, 4, with the creator's private key
2. Self-Parent Hash: the SHA3-256 hash of an event published by another participant
3. Other-Parent Hash: the SHA3-256 hash of previous event published by the participant
4. Creator's Public Key: the 256 bit public key associated with the particpants private key

#### Payload
1. Fantom Program: the fantom program to be executed by the fantom virtual machine
2. Gas: The gas allocated to execute the fantom program

*Note: Network Event Size?*
The size of the payload must be smaller than (1372 - (transport protocol overhead)) bytes. This is to ensure that an event block can be transmitted over  is smaller thant the maxiumum transmission unit (MTU) of 1500 bytes (citiation). Events larger than to prevent decreased performance from packet fragmentation (needs evidence). NB: current golang implementation has no limitation on event size as a node bundles all pending transactions into a single newly created event.

### Validation

#### Event Validation

An event is valid if the event can be verified by the public key of a participant. 

#### Payload Validation

Todo

### Genesis Event Block

A genesis event block consists of:

1. Particpant's ID: the participants public key


## Communication between Participants

A participants can send a request to synchronise their knowledge of events with another participants knowledge of events. 

A participant may send a synchronise events request to another participant. The requesting participant sends a list of events to the the participant it wishes to synchronise with. The responding participatn responds with a 

A participant can create an event and send it to any other participant. The receiving participant must validate (see Creator Validation) the event and store the event if it has a valid signature. 


### Gossip Protocol (To be removed because implementation detail) 

Participants spread event blocks across the network by exchanging information with random participants. 

A participant "gossips" by randomnly selecting two other participants and sending them a sync request. The participants respond with a sync response.

Participants must gossip continuously at a configurable interval. The interval must be between 50ms and 500ms.

### Sync Request/Response

A participant can request another for information about events. The participant will send the other participant map and since last [atropos block](#atropos-block). The receiving participant will check its store and to find event hashes that are not in the list of received hashes and respond by sending a list of events corresponding to these event hashes. The receiver stores these events to disk if they are [valid](#validation) .

A sync request contains a list of key value pairs. The keys are the numerical-ID of a participant and the value is the last known event index of the that that participant that the sending participant has knowledge of.

A sync response contains a list of key value pairs that has the numerical-ID of a participant the events 

## Consensus Algorithm

The networks events form a directed acyclic graph (DAG). Each event must have two parents and a may have a child. Participants submit events to the network to be appended to the DAG.

### Event Relationships

#### Ancestor Relationship

An event is an ancestor of another event if it is connected directly or by traversing by parent relationships. 

#### Witness Relationship

An event is a descendant of another event if it is connected, directly or by traversing child relationships. An event that is a child to another event is a witness of that it event because it 

### Events Tpes

#### Super-Ancerstored Event

An event that has ancestor events that have been created by 2/3 of the particpants is a super-ancestored event.

#### Super-Witnessed Event

An event that has child events that have been created by 2/3 of the participants is a super-witness event. A super s

#### Root Event 

An event is a root if it is:

1. [super-ancestored](#super-ancestored)
2. a [genesis event](#genesis-event)

#### Genesis Event

When a participant is added to the network, genesis event block is created by that participant. The genesis event block does not have any parent events.

#### Clotho Event

A Clotho event block is an event which is a root and has been super ancestored.

A Clotho event block is a root event block that has been witnessed by 2/3 of the network participants. An event block has been witnessed by a participant if it is an ancestor to an event block created by that participant.

#### Atropos Event 

TO DO

### Ordering and Finality

#### Event Finality

Event that have occured prior to the Atropos block are final. 

TO DO

#### Ordering events

TO DO

{backmatter}
